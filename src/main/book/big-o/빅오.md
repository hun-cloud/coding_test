# 빅오
컴퓨터 과학에서 빅오는 입력값이 커질 때 알고리즘의 실행 시간과 함께 공간
요구사항(공간 복잡도)이 어떻게 증가하는지를 분류하는데 사용된다.

아무리 복잡한 알고리즘도 입력 크기가 작으면 금방 끝나버린다. 그러므로
관심의 대상이 되는 것은 입력의 크기가 충분히 클 때다. 충분히 큰 입력에서는
알고리즘의 효율성에 따라 수행 시간이 크게 차이날 수 있기 때문이다.

빅오로 시간 복잡도를 표현할 때는 최고차 항만을 표기하며, 계수는 무시한다.
어차피 연산 횟수가 같다고 해도 어떤 연산이냐에 따라 실행 속도는 천차만별이며,
컴퓨터 과학에서는 구체적인 실행속도보다는 실행 시간의 추이에 좀 더 비중을 두기
때문이다. 4n<sup>2</sup> + 3n + 4 번만큼 계산하는 함수가 있다면 이 함수의
시간 복잡도는 4n<sup>2</sup> 만을 고려한다.

### O(1)
입력값이 아무리 커도 실행시간이 일정하다.

### O(log n)
여기서 부터는 실행 시간은 입력값에 영향을 받는다. 다음은 입력값을 반으로 나누는 함수다.
```java
public int fn(int n) {
    while(n > 1) { 
        n /= 2;
    }
    return n;
}
```
로그는 매우 큰 입력값에도 크게 영향을 받지 않는다. 사실살 O(log<sub>n</sub>)
정도면 최고의 알고리즘이라고 할 수 있다. 대표적으로 이진 검색이 이에 해당한다.

### O(n)
n의 크기만큼 실행 시간에 영향을 받으며, 알고리즘을 수행하는데 걸리는 시간은 입력값에
비례한다.
```java
public int fun(int n) {
    int r = 0;
    for (int i = 0; i < n; i++) {
        r++;
    }
    return r;
}
```
실행 시간이 선형으로 증가하기 때문에 선형 알고리즘이라고도 한다. 
정렬되지 않은 리스트에서 최대값 또는 최소값을 찾는 경우가 이에 해당한다.

### O(2log2)




